from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_community.utilities import SQLDatabase
from sqlalchemy import create_engine, inspect
import os
import json
import ast

def get_schema_info(db):
    """
    Retrieves schema information (tables and columns) from the database.
    """
    schema_info = ""
    table_names = db.get_usable_table_names()
    for table in table_names:
        schema_info += f"Table: {table}\n"
        # We can get more detailed info if needed, but table names + create statements 
        # or sample rows are usually enough. SQLDatabase.get_table_info() does this well.
    
    return db.get_table_info()

def planner_stage(llm, user_query, schema_info, history=[]):
    """
    Part 1: Planner
    Takes natural language input and schema info.
    Outputs a plan (list of SQL queries) to achieve the user's goal.
    """
    
    history_context = ""
    if history:
        history_context = "Previous conversation history:\n"
        for msg in history:
            role = "User" if msg['role'] == 'user' else "Assistant"
            history_context += f"{role}: {msg['content']}\n"
    
    prompt = f"""
    You are a SQL Expert Planner.
    
    User Goal: {user_query}
    
    {history_context}
    
    Database Schema:
    {schema_info}
    
    Your task is to generate a plan to fulfill the user's goal.
    The plan MUST be a JSON object containing a list of SQL queries to execute.
    
    Rules:
    1. You can generate multiple queries if needed (e.g., CREATE TABLE then INSERT data).
    2. You MUST NOT modify or delete the system tables: 'chat_sessions', 'chat_messages'.
    3. Return ONLY the raw JSON object, no markdown formatting, no code blocks.
    
    Output Format:
    {{
        "plan_description": "Brief description of what this plan does",
        "queries": [
            "SQL QUERY 1",
            "SQL QUERY 2"
        ]
    }}
    """
    
    response = llm.invoke(prompt)
    content = response.content.strip()
    
    # Clean up markdown code blocks if present
    if content.startswith("```json"):
        content = content[7:]
    if content.startswith("```"):
        content = content[3:]
    if content.endswith("```"):
        content = content[:-3]
        
    try:
        plan = json.loads(content)
        return plan
    except json.JSONDecodeError:
        # Fallback: try to extract just the queries if JSON parsing fails
        return {
            "plan_description": "Error parsing plan, attempting raw execution",
            "queries": []
        }

def executor_stage(db, plan):
    """
    Part 2: Executor
    Executes the SQL queries from the plan.
    Returns a log of execution results.
    """
    execution_log = []
    
    queries = plan.get("queries", [])
    if not queries:
        return [{"status": "error", "message": "No queries generated by planner."}]

    for query in queries:
        # Safety check
        lower_query = query.lower()
        if "chat_sessions" in lower_query or "chat_messages" in lower_query:
            if "drop" in lower_query or "truncate" in lower_query or "alter" in lower_query:
                execution_log.append({
                    "query": query,
                    "status": "skipped",
                    "result": "Safety violation: Cannot modify system tables."
                })
                continue

        try:
            # db.run returns a string representation of the result
            result = db.run(query)
            execution_log.append({
                "query": query,
                "status": "success",
                "result": result
            })
        except Exception as e:
            execution_log.append({
                "query": query,
                "status": "error",
                "result": str(e)
            })
            # Stop execution on error? Or continue? 
            # Usually better to stop if it's a sequence.
            break
            
    return execution_log

def responder_stage(llm, user_query, execution_log):
    """
    Part 3: Responder
    Synthesizes the execution results into a natural language response.
    """
    
    prompt = f"""
    You are a helpful Data Assistant.
    
    User Question: {user_query}
    
    Execution Log (SQL queries run and their results):
    {json.dumps(execution_log, indent=2)}
    
    Based on the execution log, provide a helpful, natural language answer to the user.
    - If data was retrieved, summarize it or present it clearly.
    - If an action was performed (created table, inserted data), confirm it.
    - If an error occurred, explain it simply.
    - Use Markdown formatting for tables or lists if appropriate.
    """
    
    response = llm.invoke(prompt)
    return response.content

def get_agent_response(message: str, db_uri: str, google_api_key: str, history: list = []) -> dict:
    # Initialize LLM
    llm = ChatGoogleGenerativeAI(
        model=os.getenv("GEMINI_MODEL", "gemini-1.5-flash"),
        google_api_key=google_api_key,
        temperature=0
    )

    # Initialize Database
    try:
        engine = create_engine(db_uri)
        db = SQLDatabase(engine)
    except Exception as e:
        return {
            "sql_query": "",
            "results": [],
            "answer": f"Database connection failed: {str(e)}"
        }

    # --- STAGE 1: PLANNER ---
    try:
        schema_info = get_schema_info(db)
        plan = planner_stage(llm, message, schema_info, history)
    except Exception as e:
        return {
            "sql_query": "",
            "results": [],
            "answer": f"Planning stage failed: {str(e)}"
        }

    # --- STAGE 2: EXECUTOR ---
    try:
        execution_log = executor_stage(db, plan)
    except Exception as e:
        return {
            "sql_query": str(plan.get("queries", [])),
            "results": [],
            "answer": f"Execution stage failed: {str(e)}"
        }

    # --- STAGE 3: RESPONDER ---
    try:
        final_answer = responder_stage(llm, message, execution_log)
    except Exception as e:
        final_answer = f"Responder stage failed: {str(e)}"

    # Format output for frontend
    # We'll take the LAST successful query/result to show in the UI "SQL" and "Results" blocks
    last_query = ""
    last_result = []
    
    for entry in execution_log:
        if entry["status"] == "success":
            last_query = entry["query"]
            # Try to parse string result back to list/dict if possible for UI table
            raw_result = entry["result"]
            try:
                # SQLDatabase.run returns stringified list of tuples usually
                # e.g. "[(1, 'A'), (2, 'B')]"
                last_result = ast.literal_eval(raw_result)
            except:
                last_result = raw_result # Keep as string if parsing fails

    return {
        "sql_query": last_query,
        "results": last_result,
        "answer": final_answer
    }
